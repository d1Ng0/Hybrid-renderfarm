= API Project 

image::data/api.png[API Project,500]
:toc:

== Writing a good API 
First of all, API in Italian is plural for BEE, so BEES is API, hence the placeholder image. 

Ok, graphics done, this week project is a learning opportunity for  building a (solid) API. I want to document the process, opinions and and tutorials in here to keep track of progresses (and failures). Plus, I don't have anyone else to share these ideas with so might as well post everything on GitHub. 

REpresentational State Transfer (REST) is a web development architecture design style which refers to logically separating your API resources so as to enable easy access, manipulation and scaling. Reusable components are written in a way so that they can be easily managed via simple and intuitive HTTP requests which can be GET, POST, PUT, PATCH, and DELETE (there can be more, but above are the most commonly used ones).

== Tools
Options for a web-server API are to implement through django, flask, bottle. My choice is to try flask, as I have been playing with django abd bottle flask seems the weapon of choice of many developers out there, plus this api won't need to support a massive load (at least for now, so flask seems appropriate).

== Motivation
My motivation to explore an hybrid approach to the traditional in-house renderfarm is to address a common pain-point of any animation or visual-effects studio, providing any failicty with additional machines when in high demand of computational power. With almost 20 years of field-experience I can list numerous occasions during which the local renderfarm, no matter how big, reached full capacity for one of the following reasons: 
* Either the client asked for substantial changes near the end of a production, requiring several department to update/change the renders
* Extra bidding was done throughout the production, which required additional rendering. In an environment where you have Artists and rigs that are working, and clients presents an occasion to work on extra shots, it seems reasonable to bid and win additional shots, but, even if the man-power and the structure (setups) are ready to be processed, the rendering power is a bottle neck when comes down to processing new shots.
* A studio normally has concurrent shows and dedicates resources according to priorities, these priorities might clash when there are two or more shows that require deliveries around the same dates. This inevitabely reduces the amount of resources available to hoter shows which are not on 'delivery priority' mode.

Because of these reasons it feels reasonable to assume a renderfarm that can scale during critical moments could be a life saver for a show, and a game-changer for those artists who spend day and night near a deadline trying to push renders through a clogged system.

== Abstract solution
There are several solution for rendering on the cloud, moreover, almost every single facility has a local renderfarm. In my opinion the scheduling, balancing and prioritization of the jobs should not be a responsability of the Artist, which should be focused on the 'artistic' aspect of creating beautiful pixels, so I think that the interface one uses to dispatch jobs should be unified and transparent to where the render will be processed. Afterall, if the system is well integrated, no one would care if the renders are processed in house or on a cloud-system.
This is the main reason why this repository proposed an agnostic abstraction layer to dispatch jobs form a local machine without overloading an Artist with multipule interfaces to launch jobs on local or cloud farms. 
The way I decided to implement this idea is by creating an API layer between the DCC software [Maya, Houdini, Nuke, etc.] and a localhost which runs a scheduler and dispatches jobs to either a local render-farm or a remote location (could be a Google, Amazon cloud provider, or even another branch of the same studio which has idle machines).
The graph below illustrate the idea. 
Also, I really wanted to explore how to create a solid RESTful API, but I needed a goos case, and this seems a perfect fit.

